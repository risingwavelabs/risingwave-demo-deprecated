import json
import os
from concurrent import futures
import ast
import numpy as np
import traceback
from model_pb2_grpc import *
import psycopg
import sql
import model_pb2_grpc
from psycopg import sql as pgsql
from model_pb2 import RecallRequest, RecallResponse, GetRatingResponse

"""
accompanied modules are generated by calling the following command

```
python3 -m grpc_tools.protoc -I. --python_out=. --grpc_python_out=. model.proto
```

"""

class RecwaveModelService(ModelServicer):
    def __init__(self):
        super(RecwaveModelService, self).__init__()
        generator_path = os.environ.get("GENERATOR_PATH", "../generator")
        with open(os.path.join(generator_path, 'items.json')) as items_json, open(os.path.join(generator_path, 'users.json')) as users_json:
            items = json.load(items_json)
            users = json.load(users_json)
            items_dict = {i['itemid']: i for i in items}
            users_dict = {u['userid']: u for u in users}
            self.items = items_dict
            self.users = users_dict
        self.conn = psycopg.connect("dbname=dev user=root host=127.0.0.1 port=4566")


    def GetRating(self, request, context):
        userid, itemid, feature_iter = request.userid, request.itemid, request.feature_values
        with self.conn.cursor() as cur:
            cur.execute(sql.GET_MOST_INTERACTED % userid)
            result = cur.fetchall()
            if len(result) == 0:
                context.set_code(grpc.StatusCode.OK)
                return GetRatingResponse(userid=userid, itemid=itemid, rating=0)
            userid, result_tuple = result[0], result[1]
            window_start, count, return_userid = ast.literal_eval(result_tuple)

        # the similarity between the most interacted item and the current one
        score = 1 / (np.linalg.norm(self.items[itemid].values(), self.items[return_userid].values()) + 0.01)
        return GetRatingResponse(userid=userid, itemid=itemid, score=score)


    def Recall(self, request, context):
        userid = request.userid
        print(f"Recall request from {userid}")
        try:
            with self.conn.cursor() as cur:
                cur.execute(sql.RECALL_SQL % userid)
                results = cur.fetchall()
                print(results)
                if len(results) < 20:
                    # randomly pick 20 items
                    context.set_code(grpc.StatusCode.OK)
                    print(f"Recall random keys for {userid}")
                    return RecallResponse(userid=userid,
                        itemid=np.random.choice(list(self.items.keys()), 20))
                else:
                    # if not, return the recalled items
                    context.set_code(grpc.StatusCode.OK)
                    print(f"Recall sorted keys for {userid}")
                    return RecallResponse(userid=userid,
                        itemid=[r[0] for r in results])
        except Exception as e:
            print(traceback.format_exc())
            context.set_code(grpc.StatusCode.INTERNAL)
            context.set_details(e)
            return RecallResponse(userid=userid, itemid=[])

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.conn.close()

    def serve(self):
        server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
        model_pb2_grpc.add_ModelServicer_to_server(
            self, server)
        server.add_insecure_port('[::]:8080')
        server.start()
        server.wait_for_termination()


if __name__ == '__main__':
    for i in range(1):
        print("making the", i, "th connection")

        conn = psycopg.connect("dbname=dev user=root host=127.0.0.1 port=4566")
        with conn.cursor() as cur:
            # the following code will panic
            # because placeholder is completely not supported
            # even varchar parsed to TypeOid 0, which isn't even defined
            cur.execute("select (2, %s);", ("2333333",))
            # cur.execute("select (2, $1);")
            results = cur.fetchall()
        print(results)

        conn.close()
